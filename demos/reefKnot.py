"""
This example considers a simplified variant of the problem from 
Section 4.4.3 of the paper

  http://www.public.iastate.edu/~jmchsu/files/Kamensky_et_al-2017-CMAME.pdf

The required shell structure geometry, in the format of a Rhino T-spline 
(although it is in fact only two B-spline patches) is available 
(compressed) here:

  https://www.dropbox.com/s/irdhyral91mmock/knot.iga.tgz?dl=1

(Credit to Fei Xu for designing this geometry, using the Rhino 3D CAD 
software.)  

For simplicity, we have omitted the singular kernel, adaptive time stepping,
and specialized nonlinear solver of the cited reference, and just empirically 
selected a sufficiently-large penalty and sufficiently-small time step for the 
simulation to reach a steady state without structural self-intersection or
divergence of the nonlinear iteration.  However, due to the choice of this
naive solver and "worst-case" uniform time step, the simulation 
takes several hours on a modern workstation to reach an interesting 
configuration.  
"""

from tIGAr import *
from tIGAr.RhinoTSplines import *
from ShNAPr.SVK import *
from ShNAPr.contact import *

if(mpisize > 1):
    if(mpirank==0):
        print("ERROR: This demo does not work in parallel.")
    exit()

# Use TSFC representation, due to complicated forms:
parameters["form_compiler"]["representation"] = "tsfc"
import sys
sys.setrecursionlimit(10000)

# Check for existence of the required data file.
FNAME = "knot.iga"
import os.path
if(not os.path.isfile(FNAME)):
    if(mpirank==0):
        print("ERROR: The required input file '"+FNAME
              +"' is not present in the working directory. "
              +"Please refer to the docstring at the top of this script.")
    exit()

####### Preprocessing #######

print("Generating extraction data...")

# Load a control mesh from element-by-element extraction data in the file
# "knot.iga", which is generated by the T-spline plugin for Rhino 3D.
controlMesh = RhinoTSplineControlMesh(FNAME)

# Assume each component of the shell structure's displacement is discretized
# using the same scalar discrete space used for the components of the
# mapping from parametric to physical space.
d = 3
splineGenerator = EqualOrderSpline(d,controlMesh)

# Fix the left ends of the ribbons.  (Forces will be applied to the right
# ends, in the variational formulation below.)
class BdryDomain(SubDomain):
    def inside(self,x,on_boundary):
        return x[0] < -6.0
for i in range(0,d):
    splineGenerator.addZeroDofsByLocation(BdryDomain(),i)

# Fix only the y- and z- components of displacement for the right ends.
class BdryDomain(SubDomain):
    def inside(self,x,on_boundary):
        return x[0] > 10.0
for i in range(1,d):
    splineGenerator.addZeroDofsByLocation(BdryDomain(),i)
    
# Write the extraction data.
DIR = "./extraction"
splineGenerator.writeExtraction(DIR)


####### Analysis #######

print("Forming extracted spline...")

# Read an extracted spline back in.
QUAD_DEG = 6
spline = ExtractedSpline(splineGenerator,QUAD_DEG)

print("Starting analysis...")

# Unlike the original reference, we simply use a linear penalty force here,
# to avoid complicated adaptive time stepping and specialized nonlinear
# solvers.
r_max = 0.15
k = 1e8
def phiPrime(r):
    if(r>r_max):
        return 0.0
    return -k*(r_max-r)
def phiDoublePrime(r):
    if(r>r_max):
        return 0.0
    return k

# Points closer together than this distance in the reference configuration
# do not interact through contact forces.
R_self = 0.4

# Displacement solution at current and previous time steps:
DELTA_T = Constant(0.00025)
y_hom = Function(spline.V)
y_old_hom = Function(spline.V)
ydot_hom = Constant(1.0/DELTA_T)*y_hom+Constant(-1.0/DELTA_T)*y_old_hom
ydot_old_hom = Function(spline.V)
yddot_hom = (ydot_hom-ydot_old_hom)/DELTA_T

# Displacement solution and time derivatives in rational form:
y = spline.rationalize(y_hom)
ydot = spline.rationalize(ydot_hom)
yddot = spline.rationalize(yddot_hom)

# Reference and deformed configurations:
X = spline.F
x = X + y

# The shell thickness:
h_th = Constant(0.004)

# The Young's modulus and Poisson ratio:
E = Constant(1e7)
nu = Constant(0.3)

# Elastic energy:
Wint = surfaceEnergyDensitySVK(spline,X,x,E,nu,h_th)*spline.dx

# Test function:
z_hom = TestFunction(spline.V)
z = spline.rationalize(z_hom)

# Variation of energy:
dWint = derivative(Wint,y_hom,z_hom)

# Mass density:
DENS = Constant(1.0)

# Inertial contribution to the residual, including a body force on the right
# ends of the ribbons.
bodyForceMag = conditional(gt(X[0],10.0),Constant(1e3),Constant(0.0))
bodyForce = as_vector([bodyForceMag,Constant(0.0),Constant(0.0)])
dWmass = DENS*h_th*inner(yddot-bodyForce,z)*spline.dx

# Mass damping:
DAMP = Constant(1.0e0)
dWdamp = DAMP*DENS*h_th*inner(ydot,z)*spline.dx

# The full nonlinear residual for the shell problem:
res = dWmass + dWint + dWdamp

# Use derivative() to obtain the consistent tangent of the nonlinear residual,
# considered as a function of displacement in homogeneous coordinates.
Dres = derivative(res,y_hom)

# Initialize contact context:
contactContext = ShellContactContext(spline,R_self,r_max,phiPrime,
                                     phiDoublePrime)

# Nonlinear problem and solver:
problem = ShellContactNonlinearProblem(contactContext,res,Dres,y_hom)
solver = PETScSNESSolver()
solver.parameters["linear_solver"] = "lu"
solver.parameters["line_search"] = "bt"
solver.parameters["relative_tolerance"] = 1e-3
extSolver = ExtractedNonlinearSolver(problem,solver)

# For x, y, and z components of displacement:
d0File = File("results/disp-x.pvd")
d1File = File("results/disp-y.pvd")
d2File = File("results/disp-z.pvd")

# For x, y, and z components of initial configuration:
F0File = File("results/F-x.pvd")
F1File = File("results/F-y.pvd")
F2File = File("results/F-z.pvd")

# For weights:
F3File = File("results/F-w.pvd")

# Total number of time steps:
N_TIME_STEPS = 6000

# Number of time steps per output file batch:
OUTPUT_SKIP = 20

# Time stepping loop:
for timeStep in range(0,N_TIME_STEPS):

    print("------- Time step "+str(timeStep)+" -------")

    # Output fields needed for visualization.
    if(timeStep % OUTPUT_SKIP == 0):
        (d0,d1,d2) = y_hom.split()
        d0.rename("d0","d0")
        d1.rename("d1","d1")
        d2.rename("d2","d2")
        d0File << d0
        d1File << d1
        d2File << d2
        # (Note that the components of spline.F are rational, and cannot be
        # directly outputted to ParaView files.)
        spline.cpFuncs[0].rename("F0","F0")
        spline.cpFuncs[1].rename("F1","F1")
        spline.cpFuncs[2].rename("F2","F2")
        spline.cpFuncs[3].rename("F3","F3")
        F0File << spline.cpFuncs[0]
        F1File << spline.cpFuncs[1]
        F2File << spline.cpFuncs[2]
        F3File << spline.cpFuncs[3]

    # Solve the nonlinear problem:
    extSolver.solve()

    # Move to the next time step:
    ydot_old_hom.assign(ydot_hom)
    y_old_hom.assign(y_hom)

####### Postprocessing #######

# Notes for plotting the results with ParaView:
#
# Load the time series from all seven files and combine them with the
# Append Attributes filter.  Then use the Calculator filter to define the
# vector field
#
# ((d0+F0)/F3-coordsX)*iHat+((d1+F1)/F3-coordsY)*jHat+((d2+F2)/F3-coordsZ)*kHat
#
# which can then be used in the Warp by Vector filter.  Because the
# parametric domain is artificially stretched out, the result of the Warp by
# Vector filter will be much smaller, and the window will need to be re-sized
# to fit the warped data.  The scale factor on the warp filter may need to
# manually be set to 1.
